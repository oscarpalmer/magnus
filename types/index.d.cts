// Generated by dts-bundle-generator v9.5.1

/**
Represents an object with `unknown` value. You probably want this instead of `{}`.

Use case: You have an object whose keys and values are unknown to you.

@example
```
import type {UnknownRecord} from 'type-fest';

function toJson(object: UnknownRecord) {
	return JSON.stringify(object);
}

toJson({hello: 'world'});
//=> '{"hello":"world"}'

function isObject(value: unknown): value is UnknownRecord {
	return typeof value === 'object' && value !== null;
}

isObject({hello: 'world'});
//=> true

isObject('hello');
//=> false
```

@category Type
@category Object
*/
export type UnknownRecord = Record<PropertyKey, unknown>;
export type PlainObject = UnknownRecord;
declare class Observer {
	private readonly element;
	private readonly options;
	private readonly handler;
	private frame;
	private readonly observer;
	private running;
	constructor(element: Element, options: MutationObserverInit, handler: ObserverCallback);
	start(): void;
	stop(): void;
	update(): void;
}
declare class Actions {
	private readonly store;
	add(name: string, target: EventTarget): void;
	clear(): void;
	create(parameters: ActionParameters): void;
	has(name: string): boolean;
	remove(name: string, target: EventTarget): void;
}
declare class Data {
	readonly value: PlainObject;
	constructor(context: Context);
}
declare class Targets {
	private readonly callbacks;
	private readonly store;
	get getters(): GetTargets;
	constructor(element: Element);
	add(name: string, element: Element): void;
	clear(): void;
	get<Target extends Element = Element>(name: string): Target | undefined;
	getAll<Target extends Element = Element>(name: string): Target[];
	has(name: string): boolean;
	remove(name: string, element: Element): void;
}
declare class Context {
	readonly name: string;
	readonly element: Element;
	readonly actions: Actions;
	readonly controller: InstanceType<ControllerConstructor>;
	readonly data: Data;
	readonly observer: Observer;
	readonly targets: Targets;
	constructor(name: string, element: Element, ctor: ControllerConstructor);
}
export type ActionParameters = {
	callback: (event: Event) => void;
	name: string;
	options: AddEventListenerOptions;
	type: string;
};
export type ControllerConstructor = new (context: Context) => Controller;
export type GetTargets = {
	/**
	 * Find elements within the controller's element
	 */
	find<Found extends Element = Element>(selector: string): Found[];
	/**
	 * Get the first element with the given target name
	 */
	get<Target extends Element = Element>(name: string): Target | undefined;
	/**
	 * Get all elements with the given target name
	 */
	getAll<Target extends Element = Element>(name: string): Target[];
	/**
	 * Does the controller have any elements with the given target name?
	 */
	has(name: string): boolean;
};
export type ObserverCallback = (element: Element, name: string, value: string, added: boolean) => void;
export declare abstract class Controller<Data extends PlainObject = PlainObject> {
	protected readonly context: Context;
	/**
	 * The controller's primary element
	 */
	get element(): Element;
	/**
	 * Controller data
	 */
	get data(): Data;
	/**
	 * Controller name
	 */
	get name(): string;
	/**
	 * The controller's targets
	 */
	get targets(): GetTargets;
	constructor(context: Context);
	/**
	 * Called when the controller is connected
	 */
	abstract connect(): void;
	/**
	 * Called when the controller is disconnected
	 */
	abstract disconnect(): void;
}
declare class Magnus {
	/**
	 * Adds a named controller to observe
	 */
	add(name: string, ctor: ControllerConstructor): void;
	/**
	 * Removes a named controller _(and all its instances)_ from observation
	 */
	remove(name: string): void;
	/**
	 * Starts the observer
	 */
	start(): void;
	/**
	 * Stops the observer
	 */
	stop(): void;
}
export declare const magnus: Magnus;

export {};
